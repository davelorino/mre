% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create_expanded_set_of_candidate_hypotheses.R
\name{create_expanded_set_of_candidate_hypotheses}
\alias{create_expanded_set_of_candidate_hypotheses}
\title{Takes a list of the current best set of hypotheses and creates an expanded set of candidate hypotheses.}
\usage{
create_expanded_set_of_candidate_hypotheses(
  x,
  target_variable,
  current_candidates,
  blacklist
)
}
\arguments{
\item{x}{A dataframe.}

\item{target_variable}{A string representing the variable you are trying to explain.}

\item{current_candidates}{A dataframe taken from the first list element of the return value of mre::prune_beam_search_results(x, n_nodes)}
}
\value{
A dataframe containing an expanded layer of hypotheses / "beam" in the hierarchical beam search space.
}
\description{
Takes a list of the current best set of hypotheses and creates an expanded set of candidate hypotheses.
}
\examples{
# Create a synthetic dataset of age, gender and income.
#' n <- 10000
#' set.seed(42)
age <- factor(sample(c("young", "adolescent", "old"), n, replace = TRUE, prob = c(0.33, 0.33, 0.34)))
gender <- factor(sample(c("male", "nonbinary", "female"), n, replace = TRUE, prob = c(0.33, 0.33, 0.34)))

# Define probabilities for income based on age and gender
income_probs <- function(age_val, gender_val) {
  if (age_val == "old" & gender_val == "male") {
    return(c("low" = 0.01, "high" = 0.99))
  } else if (age_val == "young" & gender_val == "female") {
    return(c("low" = 0.99, "high" = 0.01))
  } else {
    return(c("low" = 0.99, "high" = 0.01))
  }
}

# Generate income variable
income <- factor(mapply(function(a, g) {
  sample(c("low", "high"), 1, replace = TRUE, prob = income_probs(a, g))
}, age, gender))

# Join age, gender and income into a dataframe
x <- data.frame(age, gender, income)

# Define the targets that you want explanations for
target_variable = "income"

# Create an initial set of candidate hypotheses
first_hypotheses <- create_first_set_of_candidate_hypotheses(x, target_variable)

# Calculate GBF scores of all hypotheses in the first beam
first_level_beam_result <- calculate_gbf_of_hypothesis_set(
  x,
  second_level_beam,
  target_variable,
  target_value
)

# Prune the resutls of the first beam to only the hypotheses with good GBF scores
pruned_first_level_beam_result <- prune_beam_search_results(first_level_beam_result, n_nodes)

# Retain a dataframe of the current best candidates
current_candidates <- pruned_first_level_beam_result[[1]] \%>\%
  dplyr::mutate(hypothesis = stringr::str_remove(hypothesis, "\\\\(")) \%>\%
  dplyr::mutate(hypothesis = stringr::str_remove(hypothesis, "\\\\)")) \%>\%
  dplyr::rename(first_beam_hypothesis = hypothesis) \%>\%
  dplyr::left_join(first_level_beam, by = c("first_beam_hypothesis" = "filter_string"))

# Retain a dataframe of hypotheses to skip on future scans
blacklist <- pruned_first_level_beam_result[[2]] \%>\%
  dplyr::mutate(hypothesis = stringr::str_remove(hypothesis, "^\\\\(")) \%>\%
  dplyr::mutate(hypothesis = stringr::str_remove(hypothesis, "\\\\)$")) \%>\%
  dplyr::left_join(first_level_beam, by = c("hypothesis" = "filter_string"))

# Create a second level of hypotheses by expanding the first set + ignoring the blacklist
second_level_hypotheses <- create_expanded_set_of_candidate_hypotheses(
  x,
  target_variable,
  current_candidates,
  blacklist
)

# Check results
second_level_hypotheses
}
